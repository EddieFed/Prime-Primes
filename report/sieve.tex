\documentclass[11pt]{article}
\usepackage[paperwidth=10.2in,paperheight=11.7in]{geometry}


\usepackage{framed}

\usepackage{amsmath, amssymb}
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}

\setlength{\parindent}{0pt}
\setlength{\parskip}{12pt}
\setlength{\voffset}{-30pt}
\setlength{\hoffset}{-40pt}
\setlength{\textwidth}{600pt}
\setlength{\textheight}{720pt}
\setlength{\marginparwidth}{5pt}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\lstdefinestyle{EddiePythonStyle}{
    backgroundcolor = \color{backcolour},
    commentstyle = \color{codegreen},
    keywordstyle = \color{magenta},
    numberstyle = \tiny\color{codegray},
    stringstyle = \color{codepurple},
    basicstyle = \ttfamily\footnotesize,
    breakatwhitespace = false,         
    breaklines = true,                 
    captionpos = b,                    
    keepspaces = true,                 
    numbers = left,                    
    numbersep = 6pt,                  
    showspaces = false,                
    showstringspaces = false,
    showtabs = false,                  
    tabsize = 2,
    language = Python,
    frame = single,
    title = {Python code optimized for generating the Sieve of Eratosthenes}
}

\newcommand{\genlegendre}[4]{%
    \genfrac{(}{)}{}{#1}{#3}{#4}%
    \if\relax\detokenize{#2}\relax\else_{\!#2}\fi
}
\newcommand{\legendre}[3][]{\genlegendre{}{#1}{#2}{#3}}
\newcommand{\dlegendre}[3][]{\genlegendre{0}{#1}{#2}{#3}}
\newcommand{\tlegendre}[3][]{\genlegendre{1}{#1}{#2}{#3}}

\begin{document}
    \lstset{style=EddiePythonStyle}
    \begin{lstlisting}
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import math
import time

import numpy as np

"""
sieve() is optimized to use as little space as possible when running.
Generally in python, an Integer takes 28 bytes of memory, so working in large quantities
is unreasonable for arrays of size 1 billion. However, this uses numpy ndarrays which can
use the ctype bool taking a measly 1 byte per value. This is more time consuming to iterate
over when writing to a file, but much less memory intense allowing for much larger quantities
of primes to be generated without nearly as much memory overhead
"""

def sieve(n: int) -> np.ndarray:
    bools = np.full(n + 1, True)
    bools[0] = False
    bools[1] = False
    i = 2   # Start at 2 since 0 and 1 are not primes

    while (i * i <= n):
        # If prime[i] is not changed, then it is a prime
        if (bools[i]):
            # Update all multiples of i as False
            for j in range(i ** 2, n + 1, i):
                bools[j] = False
        # Check next number
        i += 1

    return bools


if __name__=='__main__':
    start = time.time()
    output_file = "primes.txt"

    n = 100000000           # n can be changed to anything for this project,
    primebool = sieve(n)    # we're mainly working with primes up to the limit 100,000,000
    mid = time.time()

    with open("primes.txt", "w+") as file:
        file.seek(0)    # Begins at start of file
        for i in range(n + 1):
            if (primebool[i]):
                file.write("%s\n" % i)
        file.truncate() # Wipes remaining file clean

    # Total time taken
    end = time.time()
    print(f"Generated a total of {np.count_nonzero(primebool)} primes!")
    print(f"-> Sieve runtime was {math.floor(mid-start)} seconds")
    print(f"-> Total runtime was {math.floor(end-start)} seconds")
    \end{lstlisting}


\end{document}

